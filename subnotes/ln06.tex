\chapter{Modular Arithmetics}
Chapter Description.

\section{Introduction to Modular Arithmetics}

\subsection{Motivation}
Across several computational notions, we would utilize number lines that wrap around. What do we exactly mean? \\
Think back to Project Enigma, where we increment letters by numbers, and we would like to increment the letter Z by one position. That would provide us A, but because Z is computational represented as number $25$, and A $0$, we need to wrap a number around back to $0$ whenever it exceeds $26$. \\
The mathematical operation that allows it is called a number circle. \\
On a number line, we proceed from one number to the next, until perhaps infinity; in a number circle, counting works like the hours of a clock: whenever we reach the maximum possible hour $(12)$, we notate the next hour as the minimum possible hour $(1)$. Essentially, the next number to the largest of a circle is the smallest number of a circle. \\
Mathematically, such arithmetics are known as \textbf{Modular Arithmetics}.

\subsection{Foundation}
Let us take alphabets as an example. To computationally represent them, we would use the integers in the following range:
\[\{0, 1, \dots, 24, 25\}\]
There is a one-to-one correspondence of the $26$ digits towards $26$ alphabets. To consider alphabets whose representation is temporarily larger than the maximum of this range (number circle), $25$, since there are a total of $26$ consecutive integers from $0$ in the range: \textbf{the true numerical representation of a letter is the remainder of division from its current representation divided by the size of range}.
\begin{ln-symbol}{Modulo}{}
    The Modulo operator, $\pmod$, is used in the manner:
    \[x\pmod{m} = \text{remainder of x divided by m}\]
    For example:
    \[26\pmod{26} = 0\]
\end{ln-symbol}
And as a review of the rules of remainder, let $r = x\pmod{m}$, it is ruled that $0 \leq r \leq m - 1 \land r \in Z$. \\
Therefore, symbol wise:
\[29\pmod{26} = -23\pmod{26} = 3\]
\begin{ln-symbol}{Properties of $\pmod$}{}
    \begin{bindenum}
        \item $(a + b)\pmod{n} = [a\pmod{n} + b\pmod{n}]\pmod{n}$
        \item $(a - b)\pmod{n} = [a\pmod{n} - b\pmod{n}]\pmod{n}$
        \item $(a \times b)\pmod{n} = [a\pmod{n} \times b\pmod{n}]\pmod{n}$
    \end{bindenum}
\end{ln-symbol}

\subsection{Set Representation}
For a modulo $k$, it happens that we can categorize all integers into $k$ sets $S_i$, such that:
\[S_i = {z : z\pmod{i} = i} \]
These sets are called residue classes $\pmod$ $k$. And, to mathematically express their comraderies, we may use the following symbol:
\begin{ln-symbol}{Congruency}{}
    \[x \equiv y\pmod{k} \iff (x\pmod{k} = y\pmod{k}) \]
    For example,
    \[29 \equiv -23\pmod{26}\]
\end{ln-symbol}
Let us attempt to prove a relevant theorem:
\begin{ln-think}{Prove this theorem in the following box}{}
    Prove:
    \[(a \equiv c\pmod{m} \land b \equiv d\pmod{m}) \implies (a + b \equiv c + d\pmod{m} \land ab \equiv cd\pmod{m})\]
    \tcblower
    Let $c = a + k \cdot m$, $d = b + l \cdot m$:
    \begin{align*}
        c + d
        &= a + b + (k + l) \cdot m \\
        &\equiv (a + b)\pmod{m}
    \end{align*}
    \begin{align*}
        c \dot d
        &= ab + alm + bkm + klm^2 \\
        &= ab + (al + bk + klm) \cdot m \\
        &\equiv (ab)\pmod{m}
    \end{align*}
\end{ln-think}

\section{Exponentiation}
How can we compute $x^y\pmod{m}$? \\
Well, for instance, we can compute the sequence $x\pmod{m}, x^2\pmod{m}, \dots$ up to the $y^{th}$ term, but that takes time exponential to the number of bits in $y$, which is less efficient than wanted. \\
Instead, let us not calculate all items of the sequence, but just some:
\begin{ln-theorem}{Algorithm for Modular Exponentiation}{}
    We solve the value of $x^y \mod{m}$ with the following procedure:
    \begin{bindenum}
        \item If $y$ is $0$, then return $1$. This is trivial solution!
        \item {
            Else, we'd use the following procedure:
            \begin{bindenum}
                \item Compute a new variable $z = x^{\frac{y}{2}}\pmod{m}$.
                \item If $y$ is even, then return $z^2\pmod{m}$.
                \item Else, return $z^2x\pmod{m}$
            \end{bindenum}
        }
    \end{bindenum}
    Essentially, we use the mathematical facts that:
    \[
        \begin{cases}
            x^{2a} = {(x^a)}^2 \\
            x^{2a + 1} = x \times {(x^a)}^2
        \end{cases}
    \]
\end{ln-theorem}
The concrete analysis of the above algorithm would be performed in CS170, but this algorithm holds essentially an $O(n)$ runtime, where $n$ is the number of bits in $y$. \\
This is very efficient, much more efficeint than the exponential-time naive approach.

\section{Bijections}
Take this as a side track! \\
A function is, in its nature, the relationship of sets: it is a relationship of elements from set $A$ to set $B$. Mathematically expressed, \\
\[(\forall x \in A) (f(x) \in B), f : A \rightarrow B\]
\begin{ln-define}{Injective, Surjective, Bijection}{}
    Injective, Surjective, and Bijective are all properties of functions, relationship between two sets $A$ and $B$. We call the $A$ the set of \textit{pre-images}, and $B$ the set of \textit{images}.
    \begin{bindenum}
        \item{
            \textbf{Injective}: Each image (output) has at most one pre-image (input). This type of function is thus called a "one-to-one" function.
            \begin{center}
                \begin{tikzpicture}
                    \node[circ] (A1) at (0, 0) [label=left:$A_1$] {};
                    \node[circ] (A2) at (0, 0.3) [label=left:$A_2$] {};
                    \node[circ] (B1) at (2, 0) [label=right:$B_1$] {};
                    \node[circ] (B2) at (2, 0.3) [label=right:$B_2$] {};
                    \node[circ] (B3) at (2, 0.6) [label=right:$B_3$] {};
                    \draw (A1) -- (B1);
                    \draw (A2) -- (B2);
                    \draw (0, 0.15) ellipse (0.8cm and 0.8cm);
                    \draw (2, 0.3) ellipse (0.8cm and 0.8cm);
                \end{tikzpicture}
            \end{center}
        }
        \item{
            \textbf{Surjective}: Each image (output) has at least one image (input). This type of function is "onto".
            \begin{center}
                \begin{tikzpicture}
                    \node[circ] (A1) at (0, 0) [label=left:$A_1$] {};
                    \node[circ] (A2) at (0, 0.3) [label=left:$A_2$] {};
                    \node[circ] (A3) at (0, 0.6) [label=left:$A_3$] {};
                    \node[circ] (B1) at (2, 0) [label=right:$B_1$] {};
                    \node[circ] (B2) at (2, 0.3) [label=right:$B_2$] {};
                    \draw (A1) -- (B1);
                    \draw (A2) -- (B2);
                    \draw (A3) -- (B2);
                    \draw (0, 0.3) ellipse (0.8cm and 1.2cm);
                    \draw (2, 0.15) ellipse (0.8cm and 1.2cm);
                \end{tikzpicture}
            \end{center}
        }
        \item {
            \textbf{Bijective}: A function is Bijective if the function is both injective and surjective. In other words, each image (output) has exactly one pre-image (input).
        }
    \end{bindenum}
\end{ln-define}
Let us practice this concept with some modular functions:
\begin{ln-quest}{Bijectivity of Modular Functions}{}
    Show whether the following functions are bijective:
    \[
        \begin{cases}
            f(x) \equiv x + 1\pmod{m} \\
            g(x) \equiv 2x\pmod{m}
        \end{cases}
    \]
    Where both functions map $\{0, \dots, m - 1\}$ onto themselves.
    \tcblower
    The function $f$ is bijective: every image, which are nonnegative integers from $0$ to $m - 1$, have a corresponding pre-image that is themselves. \\
    The function $g$, however, would suffer under an even $m$ as odd nonnegative images will have no preimages. In that case, $g$ is only bijective for an odd $m$.
\end{ln-quest}

\section{Inverse Operations}

\subsection{Multiplicative Inverse}
We have discussed adding as an inverse operation of subtraction, but what is the inverse operation of multiplication in a modulo sense? \\
In normal arithmetics, multiplying a number by $x$ is equivalent of dividing it by $\frac{1}{x}$, and for an equation $xy = 1$, we would call $y$ the multiplicative inverse of $x$ (because multiplying $y$ reduces the product into $1$). In linear algebra, we also had "inverse matrices" that can form multiplicative inverses via yielding a product of identity matrices $I_n = A^-1 \cdot A$. \\
In a modular sense, then, the multiplicative inverse would be defined as follows: \\
\begin{ln-define}{Multiplicative Inverse of Modular Arithmetics}{}
    For $x$, $y$, $m$ such that $xy \equiv 1\pmod{m}$, \underline{$y$ is the multiplicative inverse of $x$ modulo $m$}.
\end{ln-define}
There turns out to be conditions under which the multiplicative inverse of a number $x$ modulo $m$ exists:
\begin{ln-theorem}{Condition of Existence for Multiplicative Inverse in Modular}{}
    \textbf{Theorem}: The necessary condition of multiplicative inverse of $x$ modulo $m$ is that $gcd(m, x) = 1$.
    \tcblower
    If there exists an inverse $y$ of $x$ modular $m$, then $xy \equiv 1\pmod{m}$. Therefore, $xy = km + 1$. \\
    In that case, $xy - km = 1$. \\
    Let $c$ be a common divisor of $x$ and $m$, then that divisor must be the factor of $xy$ and $km$ too, thus the factor of $xy - km = 1$. However, the only number that can be a factor of $1$ is $1$. \\
    Therefore, assuming there exists a multiplicative inverse, then the only possible common divisor of $x$ and $m$ is $1$. Therefore, $m$ and $x$ are also coprime to each other.
\end{ln-theorem}
And the multiplicative inverse would be unique:
\begin{ln-theorem}{Uniqueness of Multiplicative Inverse under Modular}{}
    \textbf{Theorem}: The multiplicative inverse of $x$ modular $m$ is unique.
    \tcblower
    Let us state $a$ as the multiplicative inverse of $x$ modular $m$, then $ax \equiv 1\pmod{m}$. \\
    For the sake of contradiction, let's assume another distinct multiplicative inverse $b$, such that $bx \equiv 1\pmod{m}$. \\
    In that case, $bx - ax = x(b - a) \equiv 1\pmod{m}$, so if two or more distinct multiplicative inverse of $x$ modular $m$ exist, then $x$ and $m$ are not coprime to each other. This causes a contradiction with the condition of existence, which states that such inverses can only exist for coprime $x$ and $m$. \\
    Therefore, by contradiction, there can only exist one multiplicative inverse of $x$ modular $m$.
\end{ln-theorem}
While the inverse of $x$ can be written as $y = x^{-1}\pmod{m}$, this is generally considered an abuse of notation, as $x^{-1}$ can also stand for $\frac{1}{x}$ under such ambiguous context.

But we cannot just settle with knowing that an inverse exist. Let us attempt at finding a way to compute it; namely, let us produce an algorithm that can compute the multiplicative inverse of $x$ modulo $m$. \\
Let us begin our passage by thinking about greatest common divisors. Suppose that for any pair of numbers $x$, $y$, then the greatest common divisors can be expressed as:
\[d = gcd(x, y) = ax + by\]
Let's express the relationship of numbers $m$ and $x$ when there exists a multiplicative inverse of $x$ modulo $m$, in the above mathematical format:
\[1 = gcd(m, x) = am + bx\]
This would imply that $bx \equiv am + bx \equiv 1\pmod{m}$, such that $b$ is a multiplicative inverse of $x$ modulo $m$. \\
Euclid's Algorithm, which is for computing greatest common divisors, helps us to find the integers $a$ and $b$ in the above equation. Thus, let's explore Euclid's Algorithm as a method of computing modulo inverses!

\subsection{Euclid's Algorithm}
The Euclid's Algoirithm, which is more of a folk algorithm by ancient engineers, relies on the theorem below:
\begin{ln-theorem}{Reduction of GCD Computation via Modular Arithmetics}{}
    \textbf{Theorem}: Let $x \geq y > 0$, then $gcd(x, y) = gcd(y, x\pmod{y})$
    \tcblower
    Let us express $x = qy + r$, where $q \in \Z$ and $r = x\pmod{y}$. Note its an equal sign, not congruence. \\
    If their greatest common divisor $gcd(x, y) = d$ divides $x$ and $y$, then it also divides $x$ and $qy$, thus also $r = x - qy = x\pmod{y}$. \\
    Therefore, $gcd(x, y) = gcd(y, x\pmod{y})$.
\end{ln-theorem}
The Euclid's Algorithm is the process to keep applying $gcd(x, y) = gcd(y, x\pmod{y})$ until the second argument becomes $0$. At termination, the first argument is the greatest common divisor of original inputs $x$ and $y$. \\
Now, let's verify whether it works:
\begin{ln-theorem}{Correctness of Euclid's Algorithm}{}
    Prove that Euclid's Algorithm correctly computes $gcd(x, y)$.
    \tcblower
    Let us perform strong induction on the second argument (which should be the smaller of two inputs). \\
    Let the proposition for functionality of Euclid's Algorithm be that:
    \[P(n) : \text{The algorithm computes $gcd(x, n)$ for all $x$ correctly, and $x \geq y > 0$}\]
    \textbf{Base Case}: $n = 0$ \\
    In this case, $gcd(x, 0) = x$, which the algorithm correctly computes; meanwhile, the inequality stated in proposition regarding input size is maintained. \\
    \textbf{Induction Hypothesis}: Assume $P$ holds for all values $k < y$. \\
    \textbf{Induction Step}: Now's the highlight, prove that $P(y)$ holds. \\
    According to the steps of Euclid's Algorithm, $gcd(x, y) = gcd(y, x\pmod{y})$. This equality is proven in an above cube, and it is also guaranteed that $y > x\pmod{y}$ by the nature of $mod$. Therefore, $P(y)$ holds! 
\end{ln-theorem}
The runtime of Euclid's Algorithm is $O(n)$, where $n$ is the total number of bits in input $(x, y)$. This is because for every two recursion call, the first initial input is reduced by at least one bit!

\subsection{Extended Euclid's Algorithm}
The extended Euclid's Algorithm provides us the coefficients $a$ and $b$ such that $d = gcd(x, y) = ax + by$:
\setbox\codebox=\hbox{
    \begin{lstlisting}
        def extended_gcd(x, y):
            if y == 0:
                return (x, 1, 0)
            d, a, b = extended_gcd(y, x % y)
            return (d, b, a - x // y * b)
    \end{lstlisting}
}
\begin{ln-think}{Extended Euclid's Algorithm}{}
    \usebox\codebox
\end{ln-think}
Let us now consider the inner workings of it: how the return for non-base-case functions?
\begin{ln-think}{Inner Working of EEA}{}
    To establish some foundation, $d = gcd(x, y) = ay + b(x\pmod{y}) = Ax + By$. \\
    We will need to find the expressions for new coefficients $A$, $B$, in terms of previous coefficients $a$, $b$ throughout the calls of recursions.
    \begin{align*}
        d &= ay + b(x\pmod{y}) \\
        &= ay + b(x - \lfloor \frac{x}{y} \rfloor y) \\
        &= bx + (a - \lfloor \frac{x}{y} \rfloor)y \\
        A &= b \\
        B &= a - \lfloor \frac{x}{y} \rfloor
    \end{align*}
\end{ln-think}

\subsection{Brief Notes: Division via Inverse}
We have learned that to find the multiplicative inverse of $x$ modulo $m$, we would just need to solve $b$ from the equation $1 = ak + bn$, where $k=max(x,m)$ and $n$ the other. \\
Let us attempt to apply this onto solving a congruence:
\begin{ln-quest}{Solve the following congruence using modular inverses}{}
    Solve: $8x \equiv 9\mod{15}$
    \tcblower
    The inverse of $8$ modulo $15$ is $2$. How? $1 = -1 \times 15 + 2 \times 8$ \\
    So, let us multiply both sides of the congruence by $8^{-1}\pmod{15}$:
    \[x \equiv 9 \times 2 \equiv 3\pmod{15}\]
\end{ln-quest}

\section{Chinese Remainder Theorem}
